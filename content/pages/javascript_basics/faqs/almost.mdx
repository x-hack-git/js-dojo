---
title: よくある質問 全体的なことについて
slug: "/javascript_basics/faqs/almost"
---

これまでに多くの方がつまづいていた箇所をまとめています。
**質問する前にチェックしてみよう！**
**質問がなくてもチェックしてみよう！**
（自分に無い視点からの質問を見ることで勉強になります。）

注：ここにあるものと質問が被ってしまってもOKです！少しでも気になることがあればどんどん質問しましょう！


## エラーが発生した行以降は実行されるのか

構文エラーが発生した場合、後続のプログラムを解釈できないので、そこで処理が止まります。
構文エラーはそこで文章が途切れてしまっているのと同じです。

ただしchromeのデベロッパーツールのconsoleでコードを書く場合は、書かれた部分のコードだけが実行の時に解釈されるのでエラーの後に新たにJavaScriptコードを追記して行くことができます。

エラーが出たらそこでプログラムの実行は止まる、とだけ覚えておいてください！！


## 変数名の文字の区切りににアンダースコアを使ったり、大文字にしたりの種類があるが、どう使い分けるのかを知りたい

変数名は自由につけられますが、いくつか開発する現場によってスタイルがあります。
JavaScriptの言語仕様としてはどれでも間違いではないのですが、パッと見たときにあるルールに沿っていると意図がわかりやすいので、「現場毎の名前付のスタイル」があります。

こちらにまとめてあります！
参考: [補講：変数名、関数名の名前の付け方について](/extras/naming)


## 「null」と「Null」の違い

変数名は大文字小文字を区別します。なので `null` と `Null` は区別されます。

`null` はJavaScriptの予約語になっているので変数名や関数名として使用することができません！

参考: [補講：予約語について](/extras/reserved)


## 変数に別の変数を代入したら、代入した変数の値はどうなるのか

このように変数を代入した時

```
var a = 100
var c = a
```

変数 a は 100 のまま残ります。
a と c は どちらも 100 という数値の「別名」と考えてよいと思います。
変数は、値が「入っている」「箱のような」と説明されますが、データにつけられた「名前」と考えた方がより正確です。


## 真偽値以外のもの（数値や文字）がifで使われた場合どうなるのか

ルールが明確に決まっています。

```
var a = 100;
if (a) {
    console.log("aはtrue.")
} else {
    console.log("aはfalse.")
}
// aはtrue.
```

JavaScriptの場合、数値が0以外は全て true になります。
0 は flase です

では文字の場合はどうでしょうか？

```
var a = "hello";
if (a) {
    console.log("aはtrue.")
} else {
    console.log("aはfalse.")
}
// aはtrue.
```

```
var a = "";
if (a) {
    console.log("aはtrue.")
} else {
    console.log("aはfalse.")
}
// aはfalse.
```

空文字 "" 以外は全て true になります。
"0" も trueです。

このルールを全て覚える必要は一切ありません。
あれ？と思ったら、MDNを読むだけです。私も、いろんな言語を使うため、全ての言語の細かい違いを覚えられないため、しょっちゅう実際にコードを書いて確認します

参考: [MDN Truthy](https://developer.mozilla.org/ja/docs/Glossary/Truthy)


## 配列のメソッドの使い分け方

こちらをご覧ください！！

参考: [補講：配列操作をマスターする](/extras/array)


## プリミティブ型とは何か？

オブジェクトでなく、メソッドを持たないデータのことです。
以下の7つがあります。

- 数値型
- 文字列型
- 真偽値型
- undefined型
- null型
- シンボル型
- BigInt型

参考: [MDN Object（オブジェクト）](https://developer.mozilla.org/ja/docs/Glossary/object)
参考: [MDN Method（メソッド）](https://developer.mozilla.org/ja/docs/Glossary/method)


## nullとundefinedの違い

null: 箱があるけど中身がない
undefined: 箱自体がない（未定義）

厳密に区別しないといけない場面は少ないです。

参考: [null](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/null)


## console.log({hoge})のように{}で囲うのはなぜか

分解して考えて見ましょう。

```
{}
```

これがオブジェクトです。

そして、{a}のように変数を{ }に入れてオブジェクトの宣言をすると、変数名がkeyとなり、変数に格納していたデータがvalueになります。

```
var a = 100
{a} // { a: 100 } と同じ
```

こうすると、

```
console.log{"a: " + a}
```

の代わりに

```
var a = 100
console.log({a})
```

と書けるというだけの話です

違いや差分に注目する癖をつけましょう！


## どのようなときに三項演算子を使うのか

true / false で変数に入れる値を書く時、1行で変数に入る値を変えられるので、そういう場合に使うことが多いですね！

```
// dataという変数が3回登場する
let data = ""
if(check > 0){
    data = "正解！"
}else{
    data = "不正解・・・"
}
```

```
// data という変数に値を代入する処理なので1行の方がみやすい
let data = check > 0 ? "正解！" : "不正解・・・"
```


## オセロの盤面を表す2次元配列の中で特定の値がいくつ存在するかのカウント方法

このように2次元配列でオセロの盤面を表した場合、

```
// 1が黒、2が白とする
var playBoard = [
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 2, 0, 0, 0],
    [0, 0, 0, 2, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
],
```

2次元配列を1次元配列するとカウントしやすくなります。
そのものズバリの Array.prototype.flat() と言うメソッドがあります！

```
// 1が黒、2が白とする
var playBoard = [
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 2, 0, 0, 0],
    [0, 0, 0, 2, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
],
　
playBoard.flat() // [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,]
　
// 配列の要素が1のものをカウント
var count = playBoard.flat().filter(function(element) {
    return element === 1
})
```

MDNにはArrayオブジェクトのメソッド一覧があるので、名前からなんとなく機能を予測して、中の使い方を見ると良いと思います！
Array.prototype.flat() はIEだと対応してないので注意です・・・

参考: [Array.prototype.flat()](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)


## ローカル変数とはなんなのか

逆に、グローバルで宣言した変数だけ特殊と考えてもらうのが良いと思います。
関数内で宣言した変数(ローカル変数)は関数が呼び出された時点で初期化され、関数が終了すると破棄されます。

ローカル変数は、どのオブジェクトのプロパティでもありません。

関数終了時にメモリ上から破棄されるということです！


## typeof演算子の判定

typeof演算子は、このようにデータ型を出力してくれる関数です。

```
typeof 1 // "number"
```

しかし、

```
typeof null // "object"
```

となってしまうバグがあります…


## コンソールでsetIntervalを止める方法

通常、このように止めます。

```
var intervalId = setInterval(func, 200)
clearInterval(intervalId) // intervalIdを指定して繰り返しを止める
```

しかしintervalIdが不明な場合、コンソールでならリロードすればとまります。


## Symbol型はどのようなシーンで使うのか

実務的な場面でSymbolが必要になることはないと思います！長いことやってますが、実務でSymbolを使ったことは一度もありません！

ただ、全くないかというとそうでもないようで、ライブラリ開発などでは活躍する場面もあります。

例えば、Arrayオブジェクトを拡張するようなライブラリを使った場合に、ライブラリAとBで似たような処理を同じ名前で拡張してしまうと、予期しない挙動をしてしまう可能性がありますが、Symbolを使えば、名前の衝突が起きないため、このような事態を防げます。


## メモリを意識してコーディングする時が実務上で多くあるのか？

メモリを意識する場面は大きく2つあって、一つはメモリの節約です。
まず、最近市販されている一般的なPCのメモリは4GB~32GBくらいあり、かなり大容量になってきました。それでもメモリは「有限な資源」なので、メモリ使用量を節約するのはかなり重要な問題です。一般的なウェブアプリだとそこまで意識しないで開発できますが、ゲームやアドビ製品などの高性能な製品を開発する場合、メモリを全て使い切ってしまうとコンピュータがフリーズ・クラッシュしてしまうので、メモリ管理も重要になってきます。そういう場合はメモリがどのくらい使用されるのかを意識します。

もう一つは、メモリに今どういう情報が書き込まれているか？です。
変数を宣言する時、意識する・しないにかかわらず「メモリのどこかにデータを保存」しています。そしてメモリのデータが消えるタイミングやメモリのデータを共有しているか？を意識する必要がある場面は多いです。JavaScriptでは配列やオブジェクトを使った開発では重要です。
例えば、下記の同じ情報を入れたオブジェクトですが、比較すると false になりますが、これもメモリを理解しているとすんなり理解できます

```
var obj1 = { a: 100 }
var obj2 = { a: 100 }
obj1 === obj2
// false
```

```
var obj1 = { a: 100 }
var obj2 = obj1
obj1 === obj2
// true
```

動的片付け言語の場合、メモリに格納するデータにどういうデータがくるか分からないので、メモリ領域を静的型付け言語に比べて、余裕を持って確保しています。
動的型付け言語を引っ越し屋に例えると、電話一本ですぐ荷物を引き取りに駆けつけてくれるからお手軽だけど、小包一個でも2トントラックで駆けつけてしまう。
一方、静的型付け言語の場合は、荷物の大きさを事前に細かく伝えないといけないけど、小包一個なら小さい鞄で駆けつけてくれる感じですね。


## 現場でのコメントアウトの方法

普通に // でコメントします。

```
// コメント
```

理由：複数行ある場合も // を使います。エディタで一括でコメントの切り替えができるので。

非推奨のコメントの書き方

```
/* テスト */
```

現場のコーディングルールがあればそれに従うで良いと思います。
ルールがなければ、VSCodeとかのフォーマッタ(自動整形ツール)のデフォルト設定にしたがって生きるのが楽です！
